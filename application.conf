// === breaking changes ===
// 1) need batch after extract (could inject that)
// 2)

hub_datasource {
  type = "rest"
  behavior = "simple"
  base_uri = "https://stage-api-gnm.actio.com.au"
  credential {
    user = "ops@actio.com.au"
    password = "0p$@@ct10"
  }
}

dwh_datasource {
  type = "sql"
  behavior = ""
  jdbcDriver = "org.postgresql.Driver",
  connect = "jdbc:postgresql://localhost/gmdwh?user=postgres&password=postgres"
  query {
    queryTemplate = ""
  }
}

script {
  schema {}
  settings {
    namespace = "Term.Functions"
    version = "v2"
  }
  tasks {
    read-store-api {
      type = "extract"
      dataSource = ${hub_datasource}
      dataSource {
        query {
          read {
            uri = ${hub_datasource.base_uri}"/api/store"
          }
        }
      }
    }
    getdata {
      type = "transformTerm"
      term = "ds => batch(ds.data)"
    }
    template {
      type = "mergeTemplate"
      templates {
        key = "${attributes.storeId}"
        create = "insert into store (storeid,name) values ('${attributes.storeId}', '${attributes.name}')"
        update = "update store set name = '${attributes.name}' where storeid='${attributes.storeId}'"
      }
    }
    update-store-db {
      type = "datasourceupdate"
      keyL = "$key"
      keyR = "$storeid"
      changeL = "A"
      changeR = "B"
      dataSource = ${dwh_datasource}
      dataSource {
        query {
          create = "create"
          read = "select sk, storeid FROM store"
          update = "update"
        }
      }
    }
    read_dbf {
      type = extract
      dataSource {
        type = file
        behavior = DBF
        directory = "/home/maurice/Downloads/dbf/"
        filenameTemplate = "VITEM.DBF"
      }
    }
    filter {
      type = "transformTerm"
      term = "ds => distinct(ds.filter(d => d.GROUP == \"CONSULT\"), \"ITEMNO\")"
    }
    template2 {
      type = "mergeTemplate"
      templates {
        create = "insert into consult_type (consult_typeid, description) values ('${ITEMNO}', '${sq(DESCPTN)}')"
      }
    }
    update-invoice-db {
      type = "datasourceupdate"
      keyL = "${row.ITEMNO}"
      keyR = "$consult_typeid"
      changeL = "-"
      changeR = "-"
      dataSource {
        type = sql
        connect = "jdbc:postgresql://localhost/gnm_dwh?user=postgres&password=actio"
        query {
          create = "create"
          read = "select consult_typeid FROM consult_type"
        }
      }
    }

    read_db {
      type = extract
      dataSource {
        type = sql
        connect = "jdbc:postgresql://localhost/gnm_dwh?user=postgres&password=actio"
        query {
          read = "select * from public.store"
        }
      }
    }
    my_template {
      type = mergeTemplate
      templates {
        col = "${capitalise(this)}"
      }
    }
    my_term {
      type = term
      term = "ds => batch(ds.map(d => d.name + \" \" + toUpperCase(d.name)))"
    }
    read_rest {
      type = extract
      dataSource {
        type = rest
        format = "json"
        credential {
          user = "ops@actio.com.au"
          password = "0p$@@ct10"
        }
        query {
          read {
            uri = "https://stage-api-gnm.actio.com.au/api/store"
          }
        }
      }
    }
    my_lookup {
      type = lookup
      dataSource {
        type = rest
        format = "json"
        credential {
          user = "ops@actio.com.au"
          password = "0p$@@ct10"
        }
        query {
          read {
            uri = "https://stage-api-gnm.actio.com.au/api/store/${id}"
          }
        }
      }
    }
    get_id {
      type = term
      term = """ds => ds.root.data.map(x => ("record", x.id))"""
    }

    print {
      type = dump
      directory = "C:\\Users\\mauri\\Documents\\"
    }
    my_text_e {
      type = extract
      dataSource {
        type = file
        filenameTemplate = "story.txt"
      }
    }
    getlines {
      type = transformTerm
      term = "ds => batch(maprecord(ds.*.col))"
    }
    my_text_l {
      type = load
      dataSource {
        type = file
        filenameTemplate = "story2.txt"
        header = "A,B,C"
      }
    }
    parse-order-csv {
      type = "transformTerm"
      term = "ds => csv(ds, \",\")"
    }
    parse_trace {
      type = "transformTerm"
      term = "ds => (\"order\", ds(0), ds.map(a => split(a.jobreference,\"=\")).map(a => (\"trace\", a(0) -> trim(a(1)))).reduceLeft((a,b) => a mergeLeft b)) "
    }
  }
  pipelines {
    mypipe {
      pipe = "my_text_e | my_template | getlines | my_text_l"
    }
    mypipe2 {
      pipe = "my_text_e | my_template | print"
    }
    sunix {
      pipe = "parse-order-csv | parse_trace"
    }
  }
  services { }
  startup {
    exec = "mypipe"
  }
}
