include "events.conf"

agentId = edeb68ae-d299-11e7-8941-cec278b6b50a

actio_home {
  query {
    read {
      headers {
        agentId = ${agentId}
      }
      uri = "https://maurice.actio.com.au:8088/scheduledrun"
    }
  }
}
actio_sync {
  // 1 min, 2 min, 4 min, 8 min, 16 min, 32 min, 64 min
  delays = [60000,120000,240000,480000,960000,1920000,3840000]
  directory = "/home/maurice/temp/stage/"${run.id}
  query {
    create {
      uri = "https://maurice.actio.com.au:8080/api/v1/datalake/upload/files/"
    }
  }
}

hub_datasource {
  type = "rest"
  behavior = "simple"
  base_uri = "https://stage-api-gnm.actio.com.au"
  credential {
    user = "ops@actio.com.au"
    password = "0p$@@ct10"
  }
}

dwh_datasource {
  type = "sql"
  behavior = ""
  jdbcDriver = "org.postgresql.Driver",
  //connect = "jdbc:postgresql://localhost:15432/scire?user=postgres&password=afxQeY3d{Pwvh"
  connect = "jdbc:postgresql://localhost/postgres?user=postgres&password=actio"
  query {
    queryTemplate = ""
  }
}

script {
  settings {
    namespace = "actio.datapipes.task.Term.Functions"
    version = "v2"
  }
  tasks {
    read-store-api {
      type = "extract"
      dataSource = ${hub_datasource}
      dataSource {
        query {
          read {
            uri = ${hub_datasource.base_uri}"/api/store"
          }
        }
      }
    }
    getdata {
      type = "transformTerm"
      term = "ds => ds.data"
    }
    each {
      type = "each"
    }
    template {
      type = "mergeTemplate"
      templates {
        key = "${attributes.storeId}"
        create = "insert into store (storeid,name) values ('${attributes.storeId}', '${attributes.name}')"
        update = "update store set name = '${attributes.name}' where storeid='${attributes.storeId}'"
      }
    }
    update-store-db {
      type = "datasourceupdate"
      keyL = "$key"
      keyR = "$storeid"
      changeL = "A"
      changeR = "B"
      dataSource = ${dwh_datasource}
      dataSource {
        query {
          create = "create"
          read = "select sk, storeid FROM store"
          update = "update"
        }
      }
    }
    read_dbf {
      type = extract
      size = 1000
      dataSource {
        type = file
        behavior = DBF
        directory = "/home/maurice/Downloads/dbf/"
        filenameTemplate = "VACCITEM.DBF"
      }
    }
    filter {
      type = "transformTerm"
      term = "ds => distinct(ds.filter(d => d.GROUP == \"CONSULT\"), \"ITEMNO\")"
    }
    template2 {
      type = "mergeTemplate"
      templates {
        create = "insert into consult_type (consult_typeid, description) values ('${ITEMNO}', '${sq(DESCPTN)}')"
      }
    }
    update-invoice-db {
      type = "datasourceupdate"
      keyL = "${row.ITEMNO}"
      keyR = "$consult_typeid"
      changeL = "-"
      changeR = "-"
      dataSource {
        type = sql
        connect = "jdbc:postgresql://localhost/gnm_dwh?user=postgres&password=actio"
        query {
          create = "create"
          read = "select consult_typeid FROM consult_type"
        }
      }
    }

    read_db {
      type = extract
      dataSource {
        type = sql
        connect = "jdbc:postgresql://localhost/gnm_dwh?user=postgres&password=actio"
        iterate {
          until = "!this.isDefined()"
        }
        query {
          read = "select ${this.index} as index,* from public.store where ${this.index} < 5"
        }
      }
    }
    my_template {
      type = mergeTemplate
      templates {
        col = "${capitalise(this)}"
      }
    }
    my_term {
      type = term
      term = "ds => batch(ds.map(d => d.name + \" \" + toUpperCase(d.name)))"
    }
    read_rest {
      type = extract
      dataSource {
        type = rest
        format = "json"
        credential {
          user = "ops@actio.com.au"
          password = "0p$@@ct10"
        }
        query {
          read {
            uri = "https://stage-api-gnm.actio.com.au/api/store"
          }
        }
      }
    }
    my_lookup {
      type = lookup
      dataSource {
        type = rest
        format = "json"
        credential {
          user = "ops@actio.com.au"
          password = "0p$@@ct10"
        }
        query {
          read {
            uri = "https://stage-api-gnm.actio.com.au/api/store/${id}"
          }
        }
      }
    }
    get_id {
      type = term
      term = """ds => ds.root.data.map(x => ("record", x.id))"""
    }

    print {
      type = dumpFile
      directory = "/home/maurice/temp"
    }
    print_display {
      type = dump
      format = "json"
    }
    my_text_e {
      type = extract
      dataSource {
        type = file
        filenameTemplate = "story.txt"
      }
    }
    getlines {
      type = transformTerm
      term = "ds => batch(maprecord(ds.*.col))"
    }
    my_text_l {
      type = load
      dataSource {
        type = file
        filenameTemplate = "output.txt"
        query {
          create {
            line = "The 2014 median income for postcode ${numeric(this.Postcode)} is ${numeric(this.MedianIncome,\"$#,###.00\")}"
          }
        }
        
      }
    }
    parse-order-csv {
      type = "transformTerm"
      term = "ds => csv(ds, \",\")"
    }
    upper_case_text {
      type = "transformTerm"
      term = """Record("Postcode" -> numeric(this.Postcode) , "Median Income" -> numeric(this.MedianIncome))"""
    }
    read_ds {
      type = extract
      dataSource {
        type = "file"
        behavior = "dump"
        directory = "/home/maurice/temp"
        regex = ".*.ds$"
      }
    }
    read_test_csv {
      type = "extract"
      behavior = "simple"
      dataSource {
        type = "file"
        behavior = "csv"
        directory = "./test/src/main/resources/"
        query {
          read {
            filenameTemplate ="TaxableIncome2014.csv"
          }
        }
      }
    }
    write_DB {
      type = load
      dataSource {
        type = sql
        //connect = "jdbc:postgresql://localhost/gnm_dwh?user=postgres&password=actio"
        connect = "jdbc:postgresql://localhost:15432/scire?user=postgres&password=afxQeY3d{Pwvh"
        query {
          create = "insert into stage.\"agent_${run.agentId}\"(runid,configname,pipename,parameters,data) values ('${run.id}','${run.configName}','${run.pipeName}','${sq(parameters.toJson())}','${sq(array.toJson())}')"
        }
      }
    }
    read_stage {
      type = extract
      size = 1
      dataSource {
        type = "file"
        behavior = "json"
        directory = "/home/maurice/temp/stage/"
        regex = ".*.json$"
      }
    }
    unzip_tar_gz {
      type = extract
      dataSource {
        type = zip
        query {
          read {
            path = "/home/maurice/temp/fileupload/4e3a3be7-2ede-48ac-a69b-dbec80f75eea.tar.gz"
          }
        }
      }
    }
    write_stage_LFS {
      type = stage_load
      dataSource {
        type = file
        behavior = json
        directory = "/home/maurice/temp/stage/"${run.id}
        query {
          create {
            filenameTemplate = "stage_"${run.id}"_${batchId}.json"
          }
        }
      }
    }
    write_s3 {
      type = stage_load
      dataSource {
        type = s3
        behavior = json
        compression = gzip
        uri = "http://localhost:9000"
        credentials {
          accessKey = 2O9I0R3P207GGPKV217P
          accessSecret = srEChxAXAInngOH26PyO2dUPHP982siP4QuoWgQO
          //accessKey = "AKIAJXK4KSBH2I7L3AEQ"
          //accessSecret = "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"
        }
        region = "ap-southeast-2"
        bucketName = "actioteststage"
        query {
          create {
            key = "stage_"${run.id}"_${batchId}.json.gz"
          }
        }
      }
    }
    t_test_help {
      type = "transformTerm"
      term = "ds => help(ds)"
    }
    t_mergeLoad {
      type = "merge_load"
      entity = "testt"
      keys = ["policyID"]
      dataSource {
        type = "sql"
        connect = "jdbc:postgresql://localhost/datalake?user=postgres&password=actio"
      }
    }
    t_fail {
      type = transformTerm
      term = "fail"
    }
    t_assert {
      type = assert
      term = "this.Postcode != \"2000\""
      abort = "true"
      statuscode = 10
      message = "Postcode shouldn't be '2000'"
    }
  }
  pipelines {
    p_test_page {
      pipe = "read_test_csv | t_assert| print_display"
    }
    p_test_help {
      pipe = "read_test_csv(start) | upper_case_text(read_test_csv) | print_display(upper_case_text)"
    }
    file2stagefile = {
      pipe = "read_test_csv | write_stage_LFS"
    }
    p_test_sequence {
      pipe = "p_test_page && file2stagefile"
    }
    p_test_help2 {
      pipe = "read_test_csv | t_mergeLoad"
    }

    stagefile2db {
      pipe = "read_stage | write_DB"
    }
    file2s3 {
      pipe = "read_test_csv | write_s3"
    }
    test_zip {
      pipe = "unzip_tar_gz | print_display"
    }
  }
  services { }
  startup {
    exec = "p_test_page"
  }
}
